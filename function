#pragma once
void inbox()
{
	while (nowx > 10)//贴到左边
	{
		movetoleft();
		//其中包含Sleep(25);
	}
	if (inputnum == 0)//结束游戏
	{
		inboxnon=1;
		return;
	}
	//拿起木块
	isnowwood = true;
	strcpy(nowwood,input[0]);
	PrintWood(nowx + 1, nowy - 3, input[0]);
	//传送带动
	for (int i = 0; i < inputnum; i++)
	{
		strcpy(input[i], input[i + 1]);
		if(i<6) 
		{
			Printnum(inwood.body[i].X + 2,inwood.body[i].Y + 1,input[i]);
		}
	}
	inputnum--;
}
void outbox()
{
	while (nowx < 33)
	{
		movetoright();
		//其中包含Sleep(25)
	}
	if (isnowwood == false)//错误情况
	{
		system("cls");
		flag = 1;//标志出错
		return;
	}
	//放下木块
	isnowwood = false;
	outputnum++;
	//传送带动
	for (int i = outputnum; i > 0; i--)
	{
		strcpy(output[i],output[i - 1]);
		if(i<6)
			Printnum(outwood.body[i].X + 2,outwood.body[i].Y + 1,output[i]);//格式化输出 
	}
	strcpy(output[0] , nowwood);
	Printnum(outwood.body[0].X + 2,outwood.body[0].Y + 1,output[0]);//格式化输出 
}
void add(int x)
{
	if ((isnowwood == false||x>=emptynum)||emptyput[x][0]=='X')//错误情况
	{
		flag = 1;//标志出错
		return;
	}
	while (nowx < 14+5*x)
	{
		movetoright();
		//其中包含Sleep(25)
	}
	while (nowx > 14 + 5 * x)
	{
		movetoleft();
		//其中包含Sleep(25);
	}
	tostring(nowwood,tonum(nowwood)+tonum(emptyput[x]));
	Printnum(nowx + 3,nowy - 2,nowwood);//到当前货物的正中心输出
}
void sub(int x)//与add相比只把+改成了- 
{
	if ((isnowwood == false||x>=emptynum)||emptyput[x][0]=='X')//错误情况
	{
		flag = 1;//标志出错
		return;
	}
	while (nowx < 14+5*x)
	{
		movetoright();
		//其中包含Sleep(25)
	}
	while (nowx > 14 + 5 * x)
	{
		movetoleft();
		//其中包含Sleep(25);
	}
	tostring(nowwood,tonum(nowwood)-tonum(emptyput[x]));
	Printnum(nowx + 3,nowy - 2,nowwood);//到当前货物的正中心输出
}
void copyto(int x)
{
	if ((isnowwood == false||x>=emptynum))//错误情况
	{
		flag = 1;//标志出错
		return;
	}
	while (nowx < 14+5*x)
	{
		movetoright();
		//其中包含Sleep(speed)
	}
	while (nowx > 14 + 5 * x)
	{
		movetoleft();
		//其中包含Sleep(speed);
	}
	//放下物块 
	isnowwood=false;
	deletenowwood();
	strcpy(emptyput[x] ,nowwood);
	
	Printnum(emptywood.body[x].X + 2,emptywood.body[x].Y + 1,emptyput[x]) ;//格式化输出;
}
void copyfrom(int x)
{
	if (x>=emptynum||emptyput[x][0]=='X')//错误情况
	{
		flag = 1;//标志出错
		return;
	}
	while (nowx < 14+5*x)
	{
		movetoright();
		//其中包含Sleep(100)
	}
	while (nowx > 14 + 5 * x)
	{
		movetoleft();
		//其中包含Sleep(100);
	}
	//不管有没有，生成物块，isnowwood置为真 
	strcpy(nowwood,emptyput[x]);
	PrintWood(nowx + 1, nowy - 3, nowwood);
	isnowwood=1;
}
void jump(int x,int *p)
{
	if (x>n)//错误情况
	{
		flag = 1;//标志出错
		return;
	}
	*p=x-1;//回到x上一个位置循环 
}
void jumpifzero(int x,int *p)
{
	if (x>n||isnowwood==false)//错误情况
	{
		flag = 1;//标志出错
		return;
	}
	if(nowwood[0]=='0')
		*p=x-1;
}
int tonum(char s[])//字符串转化成整数 
{
	
	int len=strlen(s);
	int num=0;
	int flag=1;
	for(int i=0;i<len;i++){
		if(s[i]=='-')
		{
			flag=-1;
			continue;
		}
		else
		{
			num=num*10+s[i]-'0';
		}
	}
	return flag*num;
}
void tostring(char s[],int num)//传址调用 
{
	if(num==0) 
	{
		strcpy(s,"0\0\0");//特判 
		return ;
	}
	int cnt=0;
	int num1=num;
	while(num1!=0)//统计位数 
	{
		num1/=10;
		cnt++;
	}
	if(num<0)
		{
			num=-num;
			s[0]='-';
			cnt++;
			for(int i=cnt-1;i>=1;i--)
			{
				s[i]=num%10+'0';
				num/=10;
			}
		}
	else
	{
		for(int i=cnt-1;i>=0;i--)
		{
			s[i]=num%10+'0';
			num/=10;
		}
	}
	return;
}
int tonumstruction(char s2[])
{
	int len=strlen(s2);
	int p1=0,p2=len-1;
	bool flag1=0,flag2=0; 
	while(s2[p1]==' ')
	{
		p1++;
	}
	while(s2[p2]==' ')
	{
		p2--;
	}
	for(int i=p1;i<=p2;i++)
	{
		if(s2[i]>'9'||s2[i]<'0')
			return false;
	}
	s2[p2+1]='\0';
	int numb=tonum(s2+p1);
	if(numb>n||numb<0) return -1;
	return numb;
}
